# Tech-Study
📂엔지니어 기술 면접 스터디 - Java
- [연산자](#2)

 ## #2
#### 연산자

- **연산자와 피연산자**
  - `연산자` 연산을 수행하는 기호(+,-,*,/등)
  - `피연산자` 연산자의 작업 대상(뱐수, 상수, 리터럴, 수식) 

- **연산자의 종류**
  - `산술 연산자` 사칙 연산(+,-,*,/)과 나머지 연산(%)
  - `비교 연산자` 크고 작음(<, >, ==)
  - `논리 연산자` &&(AND) ||(OR)
  - `대입 연산자` =(우변의 값을 좌변의 저장)
 
- **연산자의 우선순위**
  - `산술 연산자` `비교 연산자` `논리 연산자` `대입 연산자` 순으로 우선순위가 높다.   
  
- **산술 변환**
  - 이항 연산자는 두 피연산자의 타입이 일치해야한다.
  ```Java
  int n = 5;
  double m = 10.5;
  float result = m + (float)n; // 형변환으로 타입 일치
  float result = m + n; // 오류x, 자동적으로 큰 타입으로 형변환 왜냐하면, 작은 타입으로 형변환 할 시 10.5가 10이 되면서 손실이 발생
  ``` 
- **증감 연산자**
  - `증가 연산자(++)` 피연산자의 값을 1 증가시킨다.
  - `감소 연산자(--)` 피연산자의 값을 1 감소시킨다. 
  - `전위형` 값이 참조되기 전에 증가시킨다
  - `후위형` 값이 참조된 후에 증가시킨다.
  ```Java
  int i = 0;
  System.out.println(i++) // 0출력
  i = 0;
  System.out.println(++i) // 1출력
  ```
- **char의 사칙연산**
  ```Java
  char c = 'a';
  int i = c + 1 // a의 아스키코드인 97 + 1이 돼서 98이 된다
  char c2 = (char)(c + 1); // char로 형변환을 해줬기 때문에 아스키 코드 98에 해당하는 b가 나온다.
  
  char c3 = c + 1; // 컴파일 에러
  char c3 = 'a' + 1; 컴파일 에러X, 리터럴 연산이기 때문에 실행과정동안 변하는 값이 아니기 때문에
  ```
- **논리연산자**
  - `||(OR결합)` 피연산자 중 어느 한 쪽만 true이면 true로 결과를 얻는다.
  ```Java
  int x = 5;
  int y = 9;
  if(x == 5 || x == 9) // true
  if(x == 3 || x == 9) // true
  if(x == 5 || x == 7) // true
  if(x == 4 || x == 3) // false
  ```
  - `&&(AND)` 피연산자 양쪽 다 true여야지 true로 결과를 얻는다.
  ```Java
  int x = 5;
  int y = 9;
  if(x == 5 || x == 9) // true
  if(x == 5 || x == 8) // false
  if(x == 3 || x == 9) // false
  ```

- **삼항연산자**
  - `조건식 ? 식1 : 식2`
  ```Java
  result = (x > y) ? x : y; //조건식이 참이면 x를 거짓이면 y를 반환
  ```
- **복합대입연산자**
  - `다양한 복합대입연산자`
  ```Java
  int i = 3;
  i += 1; // i = i + 1;
  //여기서부터 i = 3으로 초기화 했다고 가정
  i -= 1; // i = i - 1;
  i *= 3 // i = i * 3;
  i /= 3 // i = i / 3;
  i %= 3 // i = i % 3;
  ```
